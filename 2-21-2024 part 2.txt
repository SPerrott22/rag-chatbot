Hi, welcome back to the second part of the lecture on dynamic programming due to internet
connection.
We had to stop, so I will be uploading two videos, one for the first part, which is the
weighted interval scheduling and one for the knapsack problem, which is covered in the
video that you are watching now.
Let me please share my screen.
Okay that should do it.
So we covered dynamic programming as it relates to weighted interval, I'll give you another
example, as I mentioned, dynamic programming is a new paradigm, so I like you to spend
extra time reviewing them and understanding certainly today's lecture because this is
going to help you with future lectures.
This is different from divide and conquer and greedy and other methodologies that you
have seen.
So the next problem that I'd like to cover is called the knapsack problem, basically
you are given a collection of items, just one second, okay, let me just, okay, let me
just, okay, so the knapsack problem we have, we are given a collection of items, i1 through
i sub n, each of them has a size and each of them has a value.
So one of the items might be a table, it's going to have a large size and the value is
moderate, another item might be a diamond, which has a small size and a high value, and
I guess take the extreme, it could be a bag of trash, where the value is almost zero,
but the size is relatively large.
So there is no correlation between sizes and values of each item, we are given a knapsack
of size capital S, and we want to put these items in the knapsack, so I may have i1, i2,
I may decide to have i3, and then maybe the rest of it will be i5, and part of it will
be empty, so i4 is not used, i6 is not used, etc.
The goal is whatever we put in the knapsack, we need to make sure, so in this case I have
S1, S2, S3, S5, I have to make sure their total size is less than S, capital S, the size
of knapsack, otherwise it will not fit, I also need to make sure the value of item I
have, V1 plus V2, V3, V5 is maximized over all possible things that I can put in the
knapsack.
There are many versions of the knapsack, one is called a fractional knapsack, where you
can take part of an item, so you can put 10% of i4 in the knapsack.
This is an easy problem, although it may sound difficult because of the word fractional,
all we have to do is to sort the items according to their unit values, so we sort based on
this number, then we put as much of the highest unit value item in the knapsack than the next
unit value so on and so forth, and you can show easily that this solution is indeed optimal.
So we are not interested because it's trivial and usually not interesting, we are not interested
in the fractional knapsack, what we are interested is integer knapsack, and in the integer knapsack
we could have, we have to put an item in its entirely, not 10% of it, not 20% of it, so
we put i1, we put i2, i3, i5 as you see in the example.
So we assume in the integer knapsack problem, the formulation is that we can have multiple
copies of i1 put in the knapsack, even though in the problem formulation I have 1i1, 1i2,
I may decide that I want to put 2i2s in the knapsack, that's okay.
Another version of the knapsack where I can put only one of each item in the knapsack,
so either i1, I put it once or zero times, that's called the 01 knapsack problem, okay.
These two problems are both interesting and they are fairly equivalent in terms of solution
methodology, so I'm just going to focus on the integer version, the other version is
pretty much the same thing, in fact, when we build the solution you will realize that
it's pretty much the same methodology, okay.
So as with any dynamic programming approach, if you remember the weighted interval scheduling,
once we start with one interval then two interval, so what we use to increase our index is the
number of intervals we have.
Here what we can use as an index is the size of the knapsack and the number of items n.
There are other possibilities that you can try, so with all dynamic programming solutions
we have to use parameters that we want to do dynamic programming on and then when we do a few
examples we're going to go back and summarize and look at similarities and differences between
these technologies or techniques I should say.
So for this I'm going to build a table, a two-dimensional table.
Row is going to be the item, so row one I have only item one.
Row two I have item one and item two.
Row three I have item one, item two, item three, so on and so forth.
The last row I have item one, item two, all the way to item n.
So row one I have only item one, that's it.
Row five I can have item five and four and three and two and one, all of them and of course the last
row is the real problem that we are trying to solve where I have all the n items.
But admittedly having only one item or item one and two that's an easier problem than having
n numbers, n items.
So we want to do that, we want to build the solution for one item and keep increasing it.
The column is going to be the size of the knapsack, size of s.
So it's going to be one, two, all the way to the size or cardinality of the knapsack.
Okay, so look at an entry here.
This is going to be j and this is going to be row i.
So this entry says what is the optimal solution when size of the knapsack is equal to j
and then items that is available to me is i one, i two, all the way to i sub i.
That's what this entry is supposed to record to store.
So probably this problem where I have an x on it, where size of the knapsack is one
and I have only one item, more specifically is item number one,
that's the easiest problem I could imagine, probably.
Or at this equivalent to some of the easiest problem.
And the answer is easy.
If the size of one is less than or equal to one, then we have a solution.
Otherwise the value is going to be zero in the location x here.
And this location, the very last location, it says the size of the knapsack is s and I can have
items one through n.
So the final solution to the original problem is going to be stored in the bottom rightmost location.
So my goal is, in solving this problem, is to fill out the knapsack, this table starting from
this location eventually move toward that because at the bottom left, in this area,
the problems are easier, and in this area, the problem are closer to the final problem.
So that's the game plan.
That's how we're going to go about it.
So let me just do, this is again size one, size two, size three, and this is item one.
So assume value of one is five and size of one is equal to two.
So here in this location, if I have a knapsack of size one, then I cannot put any i one in it.
So the value is going to be zero.
The value of total things put in the knapsack is going to be zero.
In this location, the size of the knapsack I assume is two.
And since the size of i one is also two, I can fit one i one in the knapsack.
And its value is five because that's value of one item of i one.
Here for three, I can fit at least one i one.
In fact, by inspection, it's exactly one i one I can put in, not two.
And the value of that is five.
And you keep doing that.
If this is four, then I can put one, which I already put here.
And I can put an additional one there of i one.
So the value is going to be 10, five plus five.
So the goal is when we have this two-dimensional table that we talked about,
we're going to fill it in one row at a time from left to right.
So I go this way, then I go that way, that way, that way.
And finally, I get to the very last entry in the table.
And that's the solution to the entire problem where I have items i one all the way to i n.
And size of the knapsack is s.
So my goal is to do a row major order starting from here going to the right,
here going to the right, so on and so forth.
Initially, the problem is easier, like here, here, maybe here, here is easier.
And as I get toward the final solution, the problem gets harder.
Okay, so let's assume you have filled out the table all the way to here.
All of these values are filled in.
Okay, so question is how do I solve this?
How do I fill out this value?
Okay, so assuming all the shaded region, I already computed them.
Question, what goes in the question mark?
I'm going to represent this as the solution.
I call it maybe x at row i and row and column j.
This is x at row n and size of the knapsack.
And this is x one with knapsack of size one.
Okay, so if I can show you how to put in the question mark, x of i, j,
then in the next level, the next step, then this becomes shaded, then I compute that.
Then this becomes shaded, I compute that.
Then that becomes shaded, I go to the next row, compute that.
So one row at a time from left to right.
So all I need to show is how to do this for an arbitrary i and j.
If I can do that, then I can go one, using the same technique, I go one
entry of the table at a time, till I reach this very last point.
So question is, let's focus on x of i, j.
And remember, this is the entry, the row i one through i, i.
And this is the column, meaning the size of the knapsack, j.
So how do I do that?
So how do I do that?
For x of i, j, there are two possibilities.
There is an i, i in the solution.
There is no i, i in the solution.
There is no other possibility.
Either the solution, by solution, we mean the optimal solution, up to this point,
either has i, i in it or i, i not in it.
This is case one.
This is case two.
Once you're done understanding this problem, the knapsack problem,
please try to compare this with the weighted interval scheduling.
They are very similar.
If you recall from the weighted interval scheduling, we say a given interval
either is in the solution or is not at any given time.
So if i, i is not in the solution, then where do I get the solution?
I find the optimal solution where i, i is not there.
So that's going to be right above.
So if it's not in the solution, x of i, j is going to be x of i minus 1 j right above it here.
Let's call it y.
So this is y.
If i, i is in the solution, what is the size of i, i is going to be s, i.
So i go s, i units to the left.
And whatever is in the knapsack here, I add one extra i, i here.
That's going to give me the optimal solution, i, e.
If this is the knapsack, in case one, I'm saying there is an i, i in there.
This is a knapsack of size j, because that's what you are considering.
If there is an i, i there of size s, i, then what is the optimal way to fill out the knapsack
of size j minus s, i?
And the answer to that is exactly in this entry.
So x, in this case, x of i, j is going to be x of i minus s, i, comma j,
which is going to be this entry called z.
So this is z.
So x, i, j, the current value that I want to compute is either y or z.
It's either right above it here or is s i unit to the left.
Those are the two possibilities.
So which of these two would be optimal?
You just take the max of these two.
Whichever is higher, you put that value either case one or case two inside here.
So this is going to be the max of the one above it and the one s i unit to the left.
And if the two values of case one and case two are the same, that could happen.
Then it doesn't matter.
Your preference.
Pick anyone that you like.
Okay.
So the game plan is we have this entry.
This is item one.
This is knapsack of size one to all the way to size of the knapsack.
This is sorry, i one.
This is i one, i two.
I fill out these entries one by one.
And I'll go to the next row.
Until I get to the end and this is going to be the solution.
Okay.
This is in another word, x of n comma size of the knapsack.
There are n items in the last row.
Okay.
So we process this in row major order one go at a time till we get there.
For any given entry, doesn't matter which one.
All I have to do is to do this case analysis.
We are either in case one or case two, whichever is higher, maximum value.
I'm going to put it in the corresponding entry.
And if they are the same, it doesn't matter which one.
So the final value I get in here of the value is going to be the total value in the knapsack.
Knapsack of size n.
This value here, let's say 125 is going to be the total value of items that I include in the knapsack.
So if you just want to know the total value of the item you can take to fill out the knapsack,
the answer is this value you get in here, which by way of example is 125.
If you want to know actually which items, then you start from this entry
and you follow the pointers either up or left, depending on case one or case two.
Case one is left, case two is right, up.
So if it's case two where you go up, there is no new item.
Whenever you go to left, that means there is a new item you included.
So whenever you go to the left, you output that item in the row.
So this is maybe i minus one row.
Whenever you go up, you don't output anything.
You keep going up, you don't output anything.
You go left, you look at that row and you output the new item in that row.
If it's the second row, you output two.
If it's the fifth row, you output five.
So in summary, if you just want to know the value of the knapsack once you get to x and s,
that's the value you output that you're done.
If you want to know which items you need to backtrack all the way to the beginning,
you should also compare this with the weighted interval scheduling, very similar to that.
Where at the end, in the weighted interval scheduling, we get the total sum of the weighted
intervals. Whereas if you want to actually output the intervals, you need to backtrack
all the way to the beginning to output that one by one.
Okay, so what is the runtime of this algorithm?
It's going to be ordered for each entry of the table.
Well, first of all, how many entries are there?
N times size of the knapsack.
In this table, there are this many entries.
For each entry, I look at cases.
I need to do a lookup.
Sorry, one thing I missed here is plus value of i.
Because when I go left, I need to add the value of the item I'm adding.
So, case one and two, I do a couple of lookups, an addition, and I take a max function.
Each of this is constant operation.
There are four, five, or so such operations.
Therefore, since the number of entries is ordered n times s, the time complexity
is n times s times a constant, because constant number of operations.
Therefore, this is the runtime of the knapsack algorithm.
Okay, what about the storage of the knapsack?
Well, all you need to do when you are computing an entry, you need to know the row above it,
and everybody to the left of it.
That's all you need for this value ij, x sub ij.
You never need to go two rows above.
So, the total storage you need, if someone asks you to compute the storage,
is going to be two times size of the knapsack, at most.
It's a bit less than that, but it's order of two times knapsack,
so we're going to write order of s.
That's the storage.
If you just want to know the final value, in this example, 125.
If you want to actually backtrack an output everything,
you have to remember the entire table.
So, in that case, the storage is going to be order of ns.
So, this is only if you want to know the value, this is if you want to know the items.
The storage is different depending on what the problem is asking for.
Okay, now let's look at the time complexity again.
From the analysis we did a few minutes ago, it's order n times s.
Question.
Is this n times cardinality of s?
So, if I have eight items and the size of the knapsack is n, this value is ab.
N times s.
Is this a polynomial function?
This is the first time we are encountering such a thing, and I'll explain why.
Let's look at the problem again.
Problem is specified by n items each has a size and a value.
So, input size is equal to 2n.
There are n items, two values, size and value for each item.
Therefore, the total size is 2n.
When we say a time complexity is polynomial or not, so far we had an input of size n,
and the algorithm runs in n square, for example, n square is a polynomial function of input size.
Therefore, n square has always been a polynomial function of n of the input size.
So, if you have an algorithm like that, you will say I have a polynomial time algorithm.
Okay.
Now, here the problem is n times s is not a polynomial function of 2n or n,
because I don't know what s is. s can be n to the power 4, it could be n, or it could be 2 to the n.
I don't know that, or it could be a constant. If it's n, then the time complexity is polynomial
function of n, because it's n times n is n square. If it's n to the 4, then the time complexity
is n to the 5. That's polynomial also. If it's 2 to the power n, the time complexity is n times 2
to the n, this is not polynomial function of the input size. Okay.
So, n times s, this is this polynomial or not? We don't know. It depends on s. And since we don't
know, because in general we don't know what s is as a function of n, before actually n and s is given,
then we call this dynamic programming approach a pseudo polynomial time algorithm.
So, pseudo means it kind of depends. That's really what it means.
So, this is the first time we are observing that, where the time complexity may or may not be
polynomial depending on certain parameter of the input. And make sure you completely understand
this, that when we say an algorithm runs in polynomial or n to the 4 or whatever, we mean,
although we never said it explicitly, we mean polynomial in terms of the input size,
not in terms of some strange unknown parameters. So, that's the key point. We never explicitly said
so, but we really meant in terms of input size. Okay. So, couple of things about this problem.
This is another example of a dynamic programming approach, or DP.
The methodology is very similar to weighted interval scheduling. And you will observe that
when I talk about other algorithms for dynamic programming, they turn out to be very similar.
If I had to write a code for this, I will say for j, sorry, for i between 1 and n, 1 and n,
for j between 1 and s, x of i, j is going to be the max of the two values we mentioned.
One of them was x of i minus 1, j. The other one is x of, we need to go back
sorry, I wrote this incorrectly. This is i, j minus 1. So, let me rewrite that,
because it's very important. So, for i between 1 and n, these are the rules for j between 1 and s.
x of i, j, which is the main computation is going to be one of these values.
One is x of, I go one row above,
and j. One is, I stay in this row, but the size of the knapsack is going to be j
minus the current item size, so s of i. It's going to be one of these. Which one? I'm going to max it.
Max of these two values. This is the entire program for the algorithm we did.
We have nested loops, which slows down the computation time, but the structure of the
problem is quite simple. There is usually one such equation as such in the inner part of this
nested one or multiple nested loops. Okay, so this is very important.
Contrast this with the weighted interval scheduling, the structure looks very similar.
Except instead of having two indices, i and j, in the weighted interval, we just have one,
the number of intervals. And we'll do other problems. You will see the structure is very similar.
And proof of correctness. Well, at each stage, for any given i, j, we do an exhaustive search.
We do a case analysis, where we consider all possibilities.
And for those, we take the max value. So locally, we are doing an exhaustive search
to see the value that is being computed. Therefore, at each stage, we are computing
the optimal value because we are considering all possible values and taking the best of them.
And that's why the algorithm produces an optimal solution. So dynamic programming is where,
because of these loops, it's slower than, say, a greedy algorithm, generally speaking.
There could be an exception. Proof of correctness is fairly easy because we do a case analysis,
which is really an exhaustive search. So proof is easy. Run time is slower because
we go through every possibility because we produce many solutions.
As we discussed in dynamic programming, we produce many solutions and many of them are not useful
for us. But we don't know that till we get to the end. So in this table thing,
we don't know if any of these entries are useful or not until we get to the end and we start back
tracking. So we have to compute all these subproblems.
Only then we will know if they have been useful or not. This is the same with weighted interval
scheduling and other dynamic programming problems and solutions that you're going to cover.
Okay. So homework five. So this is it. I have given you two examples today in two different videos
for dynamic programming. Make sure you review them multiple times. Make sure you are super
comfortable with them. Because if you are, dynamic programming is going to be your best friend,
it's a very easy methodology in tackling a large number of problems. In homework,
final interview questions, what have you. But on the other hand, it's a new concept for most of us.
Therefore, we do need to spend extra time to understand it today, if possible.
We'll continue with more dynamic programming in future lectures. As I mentioned, homework
will be assigned and as usual, it's due next week. This is homework five and we have a total of six
graded homeworks. There's going to be a homework seven, which is sort of a practice for the final
taxes for the final. I'll not grade that. All right. Have a great day. Bye.
